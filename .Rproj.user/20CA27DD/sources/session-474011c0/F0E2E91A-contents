################################################################################################################
# PIERRE BRIGODE - JANVIER 2021
#  ANALYSE HYDROLOGIQUE DU MNT (VIA TAUDEM, PRINCIPALEMENT) : FONCTIONS !
################################################################################################################

##################################################################################
# LISTE DES FONCTIONS : 
#    analyse_MNT_TauDEM() : ANALYSE BASIQUE DU MNT POUR HYDROLOGIE / HYDRAULIQUE
#    EXU_to_BV() : CREATION DE CONTOURS DE BV A PARTIR D'UN D8 ET D'UN SHP
#    EXU_to_sousBV() : CREATION DE CONTOURS DE SOUS-BV A PARTIR D'UN D8 ET D'UN SHP
#    dist_BV() : CALCULS DE DISTANCES ENTRE MAILLES DE BV ET EXUTOIRES
##################################################################################


##################################################################################
# analyse_MNT_TauDEM() : ANALYSE BASIQUE DU MNT POUR HYDROLOGIE / HYDRAULIQUE
##################################################################################

# Fonction
analyse_MNT_TauDEM  <- function(nom_MNT      = "MNT_VES_IGN_005m", 
                                nom_OUT      = "VES_IGN",
                                src_thres    = 10^5, 
                                DIR_MNT      = paste0(DIR_PROJ, "01_DATA/01_MNT/"),
                                DIR_OUT      = paste0(DIR_PROJ, "02_CALCULS_MNT/VES/IGN_5m/"),
                                DIR_OSGeo4W  = "C:/Program Files/QGIS 3.4/OSGeo4W.bat") {

  # Paramètres généraux
  n           <- 2
  nom_seuil   <- paste0(as.numeric(src_thres)/1000, "k")
  
  # Remplissage des cuvettes
  demfile    <- paste0(DIR_MNT, nom_MNT, ".tif")
  felfile    <- paste0(DIR_OUT, nom_OUT, "__fel.tif")
  cmd_str    <- paste("mpiexec -n", n, "PitRemove", "-z", demfile, "-fel", felfile)
  system(cmd_str)
  
  ## D8 (directions d'écoulement et pentes)
  pfile       <- paste0(DIR_OUT, nom_OUT, "__p.tif") # pfile: D8 flow directions output
  sd8file     <- paste0(DIR_OUT, nom_OUT, "__sd8.tif") # sd8file: D8 slopes output
  cmd_str     <- paste("mpiexec -n", n, "D8Flowdir", "-fel", felfile, "-p", pfile, "-sd8", sd8file)
  system(cmd_str)
  
  # AREAD8 (nombre de mailles en amont de chaque maille !! potentiellement faux pour les rivières découpées !!)
  ad8file     <- paste0(DIR_OUT, nom_OUT, "__ad8.tif")
  cmd_str     <- paste("mpiexec -n", n, "AreaD8", "-p", pfile, "-ad8", ad8file, "-nc")
  system(cmd_str)
  
  ## Les calculs qui suivent sont dépendant du seuil de définition du réseau :
  #### On créé donc un répertoire stockant ces résultats en fonction du seuil défini
  thres_value  <- as.character(src_thres)
  DIR_OUT_S    <- paste0(DIR_OUT, nom_seuil, "\\")
  if(!dir.exists(DIR_OUT_S)) {
    dir.create(DIR_OUT_S)
  }
  
  ## THRESHOLD (définition des mailles rivières en fonction du seuil défini au préalable)
  srcfile      <- paste0(DIR_OUT_S, nom_OUT, "__src.tif")
  cmd_str      <- paste("mpiexec -n", n, "Threshold", "-ssa", ad8file, "-src", srcfile, "-thresh", thres_value)
  system(cmd_str)
  
  ## STREAMNET (constitution du réseau hydrographique)
  n          <- 1
  ordfile    <- paste0(DIR_OUT_S, nom_OUT, "__ord_tau.tif")
  treefile   <- paste0(DIR_OUT_S, nom_OUT, "__tree_tau.dat")
  coordfile  <- paste0(DIR_OUT_S, nom_OUT, "__coord_tau.dat")
  netfile    <- paste0(DIR_OUT_S, nom_OUT, "__streamnet_tau.shp")
  wfile      <- paste0(DIR_OUT_S, nom_OUT, "__w_tau.tif")
  cmd_str    <- paste("mpiexec -n", n, "StreamNet", 
                      "-fel", felfile, "-p", pfile, "-ad8", ad8file, "-src", srcfile,
                      "-ord", ordfile, "-tree", treefile, "-coord", coordfile,
                      "-net", netfile, "-w", wfile)
  system(cmd_str)
  
  ## Raster to Polygon (création d'un shapefile de contours de bassins, avec fonction GDAL incluse dans QGIS)
  w         <- paste0(DIR_OUT_S, nom_OUT, "__w_tau.tif")
  bv        <- paste0(DIR_OUT_S, nom_OUT, "__wrr.shp")
  if(file.exists(bv)) file.remove(bv)
  cmd_str   <- paste(shQuote(DIR_OSGeo4W), "gdal_polygonize", w, "-f", shQuote("ESRI Shapefile"), bv)
  system(cmd_str)
  
  ## Union / BV
  bv        <- readOGR(bv)
  bv        <- gBuffer(bv, byid=TRUE, width=0)
  bvd       <- gUnaryUnion(bv, id=bv@data$DN)
  bvd       <- SpatialPolygonsDataFrame(bvd, data.frame(BV_ID=names(bvd), row.names=names(bvd)))
  area_bv   <- gArea(bvd, byid=TRUE)
  tmp_OUT   <- substr(DIR_OUT_S, 1, nchar(DIR_OUT_S)-1)
  writeOGR(bvd, tmp_OUT, paste0(nom_OUT, "__wrr_tau"), driver="ESRI Shapefile", overwrite_layer=TRUE)
}


##################################################################################
# EXU_to_BV() : CREATION DE CONTOURS DE BV A PARTIR D'UN D8 ET D'UN SHP
##################################################################################

# Fonction
EXU_to_BV  <- function(nom_EXU      = "MNT_VES_IGN__EXU", 
                       nom_EXU_OUT  = "VES_IGN",
                       nom_MNT      = "VES_IGN",
                       DIR_EXU      = paste0(DIR_PROJ, "01_DATA/02_EXU/"),
                       DIR_DATA     = paste0(DIR_PROJ, "02_CALCULS_MNT/VES/IGN_5m/"),
                       DIR_OUT      = paste0(DIR_PROJ, "02_CALCULS_MNT/VES/IGN_5m/BV/"),
                       DIR_OSGeo4W  = "C:/Program Files/QGIS 3.4/OSGeo4W.bat") {
  
  # Chargement SHP des exutoires
  shp_EXU    <- readOGR(paste0(DIR_EXU, nom_EXU, ".shp"))
  
  # Boucle sur les exutoires
  n_EXU   <- length(shp_EXU)
  for (i in 1:n_EXU) {
    cat(paste0("BV n°", i, "/", n_EXU, "...\n"))
    
    # Export d'un SHP "temporaire" pour l'exutoire en cours
    tmp_OUT    <- substr(x=DIR_OUT, start=1, stop=nchar(DIR_OUT)-1)
    writeOGR(obj=shp_EXU[i,], dsn=tmp_OUT, layer="TMP_EXU", driver="ESRI Shapefile", overwrite_layer=TRUE)
    
    # GAGEWATERSHED (identification des BV définis par les exutoires identifiés au préalable)
    pfile      <- paste0(DIR_DATA, nom_MNT, "__p.tif")
    outfile    <- paste0(DIR_OUT, "/TMP_EXU.shp")
    gwfile     <- paste0(DIR_OUT, "/TMP_gw_tau.tif")
    cmd_str    <- paste("mpiexec -n", 2, "GageWatershed", "-p", pfile, "-o", outfile, "-gw", gwfile)
    system(cmd_str)
    
    # Raster to Polygon / BV
    bv         <- paste0(DIR_OUT, "/TMP_BV.shp")
    if(file.exists(bv)) file.remove(bv)
    cmd_str    <- paste(shQuote(DIR_OSGeo4W), "gdal_polygonize", gwfile, "-f", shQuote("ESRI Shapefile"), bv)
    system(cmd_str)
    file.remove(gwfile)
    
    # Aggrégation des différents contours
    if(i == 1) {
      BV_SUP             <- readOGR(paste0(DIR_OUT, "/TMP_BV.shp"), verbose=FALSE)
      # crs(BV_SUP)        <- CRS("+init=EPSG:2154")
      BV_SUP@data        <- shp_EXU@data[i,]
      if(length(BV_SUP) > 1) {
        BV_SUP             <- gBuffer(BV_SUP, byid=TRUE, width=0)
        BV_SUP             <- gUnaryUnion(BV_SUP)
        row.names(BV_SUP)  <- row.names(shp_EXU@data)[i]
        BV_SUP             <- SpatialPolygonsDataFrame(Sr=BV_SUP, data=shp_EXU@data[i,])
      }
    } else {
      tmp_BV             <- readOGR(paste0(DIR_OUT, "/TMP_BV.shp"), verbose=FALSE)
      # crs(tmp_BV)        <- CRS("+init=EPSG:2154")
      if(length(tmp_BV) > 1) {
        tmp_BV             <- gBuffer(tmp_BV, byid=TRUE, width=0)
        tmp_BV             <- gUnaryUnion(tmp_BV)
        row.names(tmp_BV)  <- row.names(shp_EXU@data)[i]
        tmp_BV             <- SpatialPolygonsDataFrame(Sr=tmp_BV, data=shp_EXU@data[i,])
      }
      tmp_BV@data        <- shp_EXU@data[i,]
      row.names(tmp_BV)  <- row.names(shp_EXU@data)[i]
      BV_SUP             <- bind(BV_SUP, tmp_BV)
    }
  }
  
  # Calcul de la surface drainée, attribution d'une lettre et export
  # BV_SUP             <- BV_SUP[,c("Nom", "X", "Y")]
  BV_SUP$Surfcalc    <- round(area(BV_SUP)/10^6, 2)
  writeOGR(obj=BV_SUP, dsn=tmp_OUT, layer=paste0(nom_EXU_OUT, "__BV"), driver="ESRI Shapefile", overwrite_layer=TRUE)
  
  # Export d'un shapefile avec la position des exutoires
  shp_EXU@data       <- BV_SUP@data
  writeOGR(obj=shp_EXU, dsn=tmp_OUT, layer=paste0(nom_EXU_OUT, "__EXU"), driver="ESRI Shapefile", overwrite_layer=TRUE)
  
  # Export csv
  write.table(x=shp_EXU@data, file=paste0(DIR_OUT, nom_EXU_OUT, ".csv"), 
              row.names=FALSE, col.names=TRUE, sep=";", quote=FALSE)
  
  # Suppression des fichiers "TMP"
  fich_supp <- list.files(path=DIR_OUT, pattern="TMP", full.names=TRUE)
  file.remove(fich_supp)
  cat(paste0("\n\n"))
}


##################################################################################
# EXU_to_sousBV() : CREATION DE CONTOURS DE SOUS-BV A PARTIR D'UN D8 ET D'UN SHP
##################################################################################

# Fonction
EXU_to_sousBV  <- function(nom_EXU      = "MNT_VES_IGN_005m__IGN_VES__EXU", 
                           nom_MNT      = "MNT_VES_IGN_005m",
                           seuil        = "100k",
                           DIR_DATA     = paste0(DIR_PROJ, "02_CALCULS_MNT/VES/IGN_005m/"),
                           DIR_OUT      = paste0(DIR_PROJ, "02_CALCULS_MNT/VES/IGN_005m/BV/"),
                           DIR_OSGeo4W  = "C:/Program Files/QGIS 3.4/OSGeo4W.bat") {
  
  # Découpe de la zone d'intérêt
  n           <- 2
  pfile       <- paste0(DIR_DATA, nom_MNT, "__p.tif")
  outletfile  <- paste0(DIR_OUT, nom_EXU, "__EXU.shp")
  gwfile      <- paste0(DIR_OUT, nom_EXU, "_gw_tau.tif")
  cmd_str     <- paste("mpiexec -n", n, "GageWatershed", "-p", pfile, "-o", outletfile, "-gw", gwfile)
  system(cmd_str)

  # Masque des sous-bassins présents dans les bassins versants étudiés
  w           <- raster(paste0(DIR_DATA, seuil, "/", nom_MNT, "__w_tau.tif"))
  gw          <- raster(gwfile)
  wrr         <- mask(w, gw)
  writeRaster(wrr, paste0(DIR_OUT, nom_EXU, "_", seuil, "_wrr_tau.tif"), overwrite=TRUE)
  
  # Raster to polygones !
  w          <- paste0(DIR_OUT, nom_EXU, "_", seuil, "_wrr_tau.tif")
  bv         <- paste0(DIR_OUT, nom_EXU, "__sBV_", seuil, ".shp")
  if(file.exists(bv)) file.remove(bv)
  cmd        <- paste(shQuote(DIR_OSGeo4W), "gdal_polygonize", w, "-f", shQuote("ESRI Shapefile"), bv)
  system(cmd)
  
  # Union / BV --> réécriture du shapefile
  bv        <- readOGR(bv)
  bv        <- gBuffer(bv, byid=TRUE, width=0)
  bvd       <- gUnaryUnion(bv, id=bv@data$DN)
  bvd       <- SpatialPolygonsDataFrame(bvd, data.frame(BV_ID=names(bvd), row.names=names(bvd)))
  area_bv   <- gArea(bvd, byid=TRUE)
  tmp_OUT   <- substr(DIR_OUT, 1, nchar(DIR_OUT)-1)
  writeOGR(bvd, tmp_OUT, paste0(nom_EXU, "__sBV_", seuil), driver="ESRI Shapefile", overwrite_layer=TRUE)
  
}


##################################################################################
# dist_BV() : CALCULS DE DISTANCES ENTRE MAILLES DE BV ET EXUTOIRES
##################################################################################

# Fonction
dist_BV   <- function(nom_EXU    = "VES_IGN",
                      DIR_EXU    =  paste0(DIR_PROJ, "02_CALCULS_MNT/VES/IGN_5m/BV/"),
                      seuil      = "100k",
                      nom_MNT    = "VES_IGN",
                      DIR_MNT    = paste0(DIR_PROJ, "02_CALCULS_MNT/VES/IGN_5m/")) {
  
  # Chargement du shapefile avec la position des exutoires d'intérêts
  shp_EXU       <- readOGR(paste0(DIR_EXU, nom_EXU, "__EXU.shp"))
  n_EXU         <- length(shp_EXU@data[,1])
  noms_EXU      <- shp_EXU$Nom
  # noms_EXU      <- paste0(shp_EXU$Nom, c(1:5, 1:3))
  # crs(shp_EXU)  <- crs("+init=EPSG:2154", asText=TRUE)
  
  # Répertoire de sortie
  DIR_OUT     <- substr(DIR_EXU, 1, nchar(DIR_EXU)-1)

  # Boucle sur les exutoires
  for (i in 1:n_EXU) {
    cat(paste0("BV n°", i, "/", n_EXU, "...\n"))
    tmp_nom_EXU        <- noms_EXU[i]
    nom_RES_OUT        <- paste0(DIR_OUT, "/TAB_DIST_", nom_EXU, "__", seuil, "__", tmp_nom_EXU, ".res")
    
    # Si le fichier existe : on ne refait pas le calcul !
    if(!file.exists(nom_RES_OUT)) {
      
      # Export d'un SHP "temporaire" pour l'exutoire en cours
      writeOGR(obj=shp_EXU[i,], dsn=DIR_OUT, layer="TMP_EXU", driver="ESRI Shapefile", overwrite_layer=TRUE)
      
      # Surfaces contributives en amont de l'exutoire considéré
      n             <- 1
      pfile         <- paste0(DIR_MNT, nom_MNT, "__p.tif")
      ofile         <- paste0(DIR_OUT, "/TMP_EXU.shp")
      ad8file       <- paste0(DIR_OUT, "/TMP_EXU_ad8.tif")
      cmd_str       <- paste("mpiexec -n", n, "AreaD8", "-p", pfile, "-o", ofile, "-ad8", ad8file, "-nc")
      system(cmd_str)
      
      # Découpe des différents rasters
      ra            <- raster(ad8file)
      rp            <- raster(pfile)
      rp_sta        <- crop(rp, ra)
      rp_sta        <- mask(rp_sta, ra)
      writeRaster(rp_sta, paste0(DIR_OUT, "/TMP_EXU_p.tif"), overwrite=TRUE)
      rs            <- raster(paste0(DIR_MNT, "/", seuil, "/", nom_MNT, "__src.tif"))
      rs_sta        <- crop(rs, ra)
      rs_sta        <- mask(rs_sta, ra)
      writeRaster(rs_sta, paste0(DIR_OUT, "/TMP_EXU_src.tif"), overwrite=TRUE)
      wrr           <- raster(paste0(DIR_MNT, "/", seuil,"/", nom_MNT, "__w_tau.tif"))
      wrr_sta       <- crop(wrr, ra)
      wrr_sta       <- mask(wrr_sta, ra)
      writeRaster(wrr_sta, paste0(DIR_OUT, "/TMP_EXU_wrr.tif"), overwrite=TRUE)
      
      # Calcul des distances de chaque maille à la maille "rivière" la plus proche
      pfile         <- paste0(DIR_OUT, "/TMP_EXU_p.tif")
      srcfile       <- paste0(DIR_OUT, "/TMP_EXU_src.tif")
      distfile      <- paste0(DIR_OUT, "/TMP_EXU_dist.tif")
      cmd_str       <- paste("mpiexec -n", 1, "D8HDistTostrm", "-p", pfile, "-src", srcfile, "-dist", distfile)
      system(cmd_str)
      
      # Calcul des distances jusqu'à l'exutoire
      src           <- raster(ad8file)
      thres         <- cellStats(src, "max")
      distexufile   <- paste0(DIR_OUT, "/TMP_EXU_dist_exu.tif")
      cmd_str       <- paste("mpiexec -n", n, "D8HDistTostrm",  "-p", pfile, "-src", ad8file, "-dist", distexufile, "-thresh", thres)
      system(cmd_str)
      
      # Récupération des distances dans un data.frame
      dist            <- raster(distfile)
      dist_exu        <- raster(distexufile)
      df_dist         <- data.frame(wrr=wrr_sta[], dist_riv=dist[], dist_exu=dist_exu[])
      # df_dist         <- na.omit(df_dist) # Et oui, certains bassins n'ont pas de mailles rivières !
      ind             <- which(!is.na(df_dist$dist_exu))
      df_dist         <- df_dist[ind,]
      df_dist$dist_riv  <- round(df_dist$dist_riv, 0)
      df_dist$dist_exu  <- round(df_dist$dist_exu, 0)
      df_dist$riv_exu   <- round(df_dist$dist_exu - df_dist$dist_riv,0)
      
      # Temps de parcours
      # df_dist$dt_exu  <- round((df_dist$dist_riv/vit_versant + df_dist$riv_exu/vit_riv))
      
      # Suppression des fichiers "TMP"
      fich_supp <- list.files(path=DIR_OUT, pattern="TMP", full.names=TRUE)
      file.remove(fich_supp)
      
      # EXPORT DES DISTANCES DANS UN FICHIER TXT
      write.table(x=df_dist, file=nom_RES_OUT, row.names=FALSE, col.names=TRUE, sep=";", quote=FALSE)
      # save(df_dist, file=paste0(DIR_OUT, "/TAB_DIST_", nom_seuil, "_", nom_shp_EXU, "__", nom_EXU, ".RData"))
    }
  }
}
